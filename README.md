


Домашнее задание к занятию "3.1. Работа в терминале, лекция 1"

1.Ознакомьтесь с графическим интерфейсом VirtualBox, посмотрите как выглядит виртуальная машина, которую создал для вас
Vagrant, какие аппаратные ресурсы ей выделены. Какие ресурсы выделены по-умолчанию?  
Ответ
По умолчанию выдано 2 CPU и 1024 MB RAM  
[скриншот](https://drive.google.com/file/d/1Tc3lQRyYFO_xWCsJiCLKhCCWcXSF5qnn/view?usp=sharing)  

2.Ознакомьтесь с возможностями конфигурации VirtualBox через Vagrantfile: документация. Как добавить оперативной памяти
или ресурсов процессора виртуальной машине?  
Ответ: Необходимо изменить конфиг файл vagrantfile и перезапустить ВМ (vagrant reload).  
Например 

 Vagrant.configure("2") do |config|  

 	config.vm.box = "bento/ubuntu-20.04"
	config.vm.provider "virtualbox" do |v|
		v.memory = 4128
		v.cpus = 4
	end
 end   
3. Какой переменной можно задать длину журнала history, и на какой строчке manual это описывается?  
 Ответ: Описывается начиная с 792 строчки манула  

4. Что делает директива ignoreboth в bash?  
Ответ: Директива ignoreboth делает тоже самое что и директива ignorespace:ignoredups.
Если в файл ~/.bashrc добавить строку HISTCONTROL=ignoreboth или
HISTCONTROL=ignoreboth:erasedups в истории не будут сохраняться строки начинающиеся с символа пробел и дублирующиеся
(совпадающие с последней выполненной) команды.  
5. В каких сценариях использования применимы скобки {} и на какой строчке man bash это описано?  
Ответ: Строка 241, {} применяется для создания составных комманд, команды находящиеся в {} будут выполнены в
контексте текущего процесса (терминала), и результаты их вызова будут сохранены в текущем контексте (можно задать
функции имя и в последствии в данном терминале неоднократно вызывать её).
Команды выполненные в () будут исполнятся в дочернем процессе и после отработки удаляться из памяти.  
6. Основываясь на предыдущем вопросе, как создать однократным вызовом touch 100000 файлов?
А получилось ли создать 300000? Если нет, то почему?  
Ответ: touch {1..300000} не удалось создать без изменения переменной ARG_MAX (увеличить ограничение 
на объём передаваемых аргументов комманде) в большинстве случаев не получится.  
[Скриншот](https://drive.google.com/file/d/1NMtObGmaZMqxc-ZnQyDUpUp6tWdXFJWi/view?usp=sharing) 
7. В man bash поищите по /\[\[. Что делает конструкция [[ -d /tmp ]].  
Ответ: Конструкция [[ -d /tmp ]] вернёт 0 при наличии каталога /tmp.  
8. Основываясь на знаниях о просмотре текущих (например, PATH) и установке новых переменных; командах,
которые мы рассматривали, добейтесь в выводе type -a bash в виртуальной машине наличия первым пунктом в списке  
Ответ: 
# Создаем каталог
mkdir /tmp/new_path_directory
# Копируем в него файл bash
cp /bin/bash /tmp/new_path_directory/
# Добавляем каталог в переменную $PATH (в начало) 
PATH=/tmp/new_path_directory/bash:$PATH
# Выводим переменную, чтобы убедиться в корректности
echo $PATH
# Выполняем type -a
type -a bash  
[Скриншот ](https://drive.google.com/file/d/1ig26zF7p1cSCV1-N3K9PhLDB4FYe5nQB/view?usp=sharing) 
9. Чем отличается планирование команд с помощью batch и at?  
At используется для планирования разовой задачи, которая должна выполниться в определенное время
Batch используется для выполнения разовой задачи, когда позволит средняя нагрузка 
(в man указано, когда средняя нагрузка упадет ниже 1.5)  


# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2


Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете   
что она могла бы быть другого типа.

Ответ:  cd - это shell builtin команда, то есть команда, которая вызывается напрямую в shell, а не как   
внешняя исполняемая. Если бы она была внешней, то запускалась бы в отдельном процессе но мы этого не наблюдаем

Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l?  

Ответ: grep <some_string> <some_file> -c


Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

Ответ: [Скриншот ](https://drive.google.com/file/d/1RIWoAj_d2Es2GcXuBL92W9FefNR4PLms/view?usp=sharing)  

Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

Ответ: Для этого откроем второй терминал для наглядности и с имитируем ошибку [пример](https://drive.google.com/file/d/1lJYSAsYHm1Wr0A8oUyt434tIECdvlx3o/view?usp=sharing)
ls -l \root 2>/dev/pts/1

Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.  
Ответ: Да получиться например вот так:  
cat <test1.txt >test.txt  
vagrant@vagrant:~$ echo Привет >test1.txt  
vagrant@vagrant:~$ cat <test1.txt >test.txt  
vagrant@vagrant:~$ cat test.txt  
Привет  

Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY?  
Сможете ли вы наблюдать выводимые данные?

Ответ: Да получиться  

Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните
echo netology > /proc/$$/fd/5? Почему так происходит?

Ответ: bash 5>&1 -перенаправит вывод с созданного дескриптора 5 в stdout (дескриптор 1).
echo netology > /proc/$$/fd/5 -выведет в дескриптор 5 "netology",
т.к. дескриптор 5 перенаправлен в stdout "netology" мы увидим в терминале.  


Получится ли в качестве входного потока для pipe использовать только stderr команды,
не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout 
команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный
новый дескриптор, который вы научились создавать в предыдущем вопросе.

Решение: 

vagrant@vagrant:~$ ls -l /root 9>&2 2>&1 1>&9 |grep denied -c   
1

9>&2 - новый дескриптор перенаправили в stderr  
2>&1 - stderr перенаправили в stdout   
1>&9 - stdout - перенаправили в в новый дескриптор  

Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

Ответ: Выводится список переменных окружения для процесса, под которым выполняется текущая оболочка  
Аналогичный вывод можно получить с помощью команды printenv

Используя man, опишите что доступно по адресам /proc//cmdline, /proc//exe

Ответ: /proc/[pid]/cmdline - файл только на чтение, который содержит строку запуска процессов, 
кроме зомби-процессов 
/proc/[pid]/exe - сожержит полное имя выполняемого файла для процесса 


Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с
помощью /proc/cpuinfo

Ответ [скриншот](https://drive.google.com/file/d/1317WVYOJPo3wOyYT_Dz4t3eLgcmCpB7B/view?usp=sharing)

При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить
командой tty, которая упоминалась в лекции 3.2
Решение:
По умолчанию при запуске команды через SSH не выделяется TTY. Если же не указывать команды,
то TTY будет выдаваться, так как предполагается, что будет запущен сеанс оболочки. Полагаю, что изменить поведение 
можно через ssh localhost с последующей авторизацией и выполнением 'tty'. Либо через ssh -t localhost 'tty'


Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это,
воспользовавшись reptyr. Например, так можно перенести в screen процесс,
который вы запустили по ошибке в обычной SSH-сессии.

Решешие: Получилось после правки /proc/sys/kernel/yama/ptrace_scope

Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

Ответ tee - получает значения из stdin и записывает их в stdout и файл.Будет работать т.к.
в данном случае запись в файл будет осуществляться командой tee запущенной от рута
(и соответственно имеющей необходимые права).


### Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

1.Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой,
это shell builtin, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете
запустить strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, которые
делает сам bash при старте. Вам нужно найти тот единственный, который относится именно к cd.

Ответ: вводим  strace /bin/bash -c cd /tmp и находим _chdir()_

2. Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:

vagrant@netology1:~$ file /dev/tty
/dev/tty: character special (5/0)
vagrant@netology1:~$ file /dev/sda
/dev/sda: block special (8/0)
vagrant@netology1:~$ file /bin/bash
/bin/bash: ELF 64-bit LSB shared object, x86-64

Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.
Ответ Аналогично командой strace смотрим системные вызовы openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3
Файл базы типов - /usr/share/misc/magic.mgc

3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности  
сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает  
писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении  
потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе). 
Ответ: Попробовал с текстовым редактором vim

vagrant@vagrant:~$ lsof -p 1126
...
vi      1126 vagrant    4u   REG  253,0    12288  526898 /home/vagrant/.tst_bash.swp (deleted)


vagrant@vagrant:~$ echo '' >/proc/1126/fd/4



где 1126 - PID процесса vi
4 - дескриптор файла , который предварительно удалил. 

4.Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
Ответ  Нет не занимают

5. В iovisor BCC есть утилита opensnoop:

root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc

На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты?  
Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по установке.

Ответ. 

6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается  
альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС. 

Ответ: системный вызов uname()
Цитата 
     Part of the utsname information is also accessible  via  /proc/sys/ker‐
       nel/{ostype, hostname, osrelease, version, domainname}.  
7.Чем отличается последовательность команд через ; и через && в bash? Например:

root@netology1:~# test -d /tmp/some_dir; echo Hi
Hi
root@netology1:~# test -d /tmp/some_dir && echo Hi
root@netology1:~#

Есть ли смысл использовать в bash &&, если применить set -e?
Ответ:

&& -  условный оператор, 
а ;  - разделитель последовательных команд

test -d /tmp/some_dir && echo Hi - в данном случае echo  отработает только при успешном заверщении команды test

set -e - прерывает сессию при любом ненулевом значении исполняемых команд в конвеере кроме последней.
в случае &&  вместе с set -e- вероятно не имеет смысла, так как при ошибке , выполнение команд прекратиться. 

8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях? 

Ответ:
-e прерывает выполнение исполнения при ошибке любой команды кроме последней в последовательности 
-x вывод трейса простых команд 
-u неустановленные/не заданные параметры и переменные считаются как ошибки, с выводом в stderr текста ошибки и   
выполнит завершение неинтерактивного вызова
-o pipefail возвращает код возврата набора/последовательности команд, ненулевой при последней команды или 0   
для успешного выполнения команд.

По сути, для сценария , повышает деталезацию вывода ошибок(логирования), 
и завершит сценарий при наличии ошибок, на любом этапе выполнения сценария, кроме последней завершающей команды

9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).
Ответ:

S*(S,S+,Ss,Ssl,Ss+) - Процессы ожидающие завершения (спящие с прерыванием "сна")
I*(I,I<) - фоновые(бездействующие) процессы ядра

доп символы это доп характеристики, например приоритет.

* ### Домашнее задание к занятию "3.4. Операционные системы, лекция 2"


1.На лекции мы познакомились с node_exporter. В демонстрации его исполняемый файл запускался в background.
Этого достаточно для демо, но не для настоящей production-системы, где процессы должны находиться под внешним 
управлением. Используя знания из лекции по systemd, создайте самостоятельно простой unit-файл для node_exporter:
поместите его в автозагрузку,
предусмотрите возможность добавления опций к запускаемому процессу через внешний
файл (посмотрите, например, на systemctl cat cron),
удостоверьтесь, что с помощью systemctl процесс корректно стартует, 
завершается, а после перезагрузки автоматически поднимается.

Решение

Node Exporter установлен и запускается.
создан unit-файл для Node Exporter предусматривающий добавление опций $OPTIONS к запускаемому процессу
через внешний файл  
**/etc/sysconfig/node_exporter**
командой  
**sudo systemctl enable node_exporter Node Exporter** добавлен в автозагрузку
node exporter корректно стартует, завершается и после перезагрузки автоматически поднимается

У Node Exporter имеется переменная окружения для добавления опций к запускаемому процессу

2.Ознакомьтесь с опциями node_exporter и выводом /metrics по-умолчанию. Приведите несколько опций, 
которые вы бы выбрали для базового мониторинга хоста по CPU, памяти, диску и сети.

--collector.disable-defaults  
--collector.cpu   
--collector.cpufreq  
--collector.meminfo  
--collector.diskstats  
--collector.netstat  

3.Установите в свою виртуальную машину Netdata. Воспользуйтесь готовыми пакетами 
для установки (sudo apt install -y netdata). После успешной установки:
в конфигурационном файле /etc/netdata/netdata.conf в секции [web] замените значение с localhost на bind to = 0.0.0.0,
добавьте в Vagrantfile проброс порта Netdata на свой локальный компьютер и сделайте vagrant reload:
config.vm.network "forwarded_port", guest: 19999, host: 19999
После успешной перезагрузки в браузере на своем ПК (не в виртуальной машине) вы должны суметь зайти на localhost:19999.
Ознакомьтесь с метриками, которые по умолчанию собираются Netdata и с комментариями, которые даны к этим метрикам.
Решение  
Netdata установлена на виртуальной машине и открывается с хоста
[скрин](https://drive.google.com/file/d/1l3TE5yjwLbT69Ilmb2MuYtF0xjDI0IZ-/view?usp=sharing)

4.Можно ли по выводу dmesg понять, осознает ли ОС, что загружена не на настоящем оборудовании, 
а на системе виртуализации?
Ответ
Да, данная информация содержится в dmesg


5.Как настроен sysctl fs.nr_open на системе по-умолчанию? Узнайте, что означает этот параметр. Какой другой существующий
лимит не позволит достичь такого числа (ulimit --help)?

Ответ
nr_open - означает максимальное число дескрипторов, которые может использовать процесс. 
Но этого значения не дает достичь другой лимит

vagrant@vagrant:~$ ulimit -n
1024

6.Запустите любой долгоживущий процесс (не ls, который отработает мгновенно, а, например, sleep 1h) в отдельном 
неймспейсе процессов; покажите, что ваш процесс работает под PID 1 через nsenter. Для простоты работайте в данном
задании под root (sudo -i). Под обычным пользователем требуются дополнительные опции (--map-root-user) и т.д.

Решение 
`vagrant@vagrant:~$ sudo unshare -f --pid --mount-proc sleep 1h  
vagrant@vagrant:~$ ps -aux | grep sleep  
root        2517  0.0  0.4  11864  4624 pts/1    S+   14:02   0:00 sudo unshare -f --pid --mount-proc sleep 1h  
root        2518  0.0  0.0   8080   592 pts/1    S+   14:02   0:00 unshare -f --pid --mount-proc sleep 1h   
root        2519  0.0  0.0   8076   580 pts/1    S+   14:02   0:00 sleep 1h   

vagrant@vagrant:~$ sudo nsenter --target 2519 --pid --mount   
root@vagrant:/# ps aux   
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND   
root           1  0.0  0.0   8076   580 pts/1    S+   14:02   0:00 sleep 1h   
root           2  0.0  0.4   9836  4144 pts/2    S    14:05   0:00 -bash   
root          11  0.0  0.3  11492  3292 pts/2    R+   14:05   0:00 ps aux    
`
7.Найдите информацию о том, что такое :(){ :|:& };:. Запустите эту команду в своей виртуальной машине Vagrant
с Ubuntu 20.04 (это важно, поведение в других ОС не проверялось). Некоторое время все будет "плохо",
после чего (минуты) – ОС должна стабилизироваться. Вызов dmesg расскажет, какой механизм помог автоматической 
стабилизации. Как настроен этот механизм по-умолчанию, и как изменить число процессов, которое можно создать в сессии?

Ответ
Судя по информации, что я нашел в интернете - это fork bomb Её можно переписать в виде

:(){  
 :|:&  
};:   

или  

bomb() {    
 bomb | bomb &   
}; bomb   

Данная функция рекурсивно вызывает себя и передается через пайп другому вызову этой же функции (в фоне).
По сути запускаются 2 фоновых процесса, каждый из которых вызывает еще два фоновых процесса 
и тд, пока не закончатся ресурсы.  

[ 5667.545996] cgroup: fork rejected by pids controller in /user.slice/user-1000.slice/session-6.scope

vagrant@vagrant:~$ ulimit -u
3571
 Также максимальное количество процессов для пользователя можно изменить командой ulimit -u <число> или 
в файле _cat etc/security/limits.conf_
Изменить максимальное количество PID можно посредством команд  
sysctl -w kernel.pid_max=<число>,echo <число> >
/proc/sys/kernel/pid_max   
или задать переменную kernel.pid_max в файле  _/etc/sysctl.conf_
Ограничение на максимальное число процессов на уровне системы установлено в переменной _DefaultTasksMax_:
systemctl show --property DefaultTasksMax   
изменить данную переменную можно в файле _/etc/systemd/system.conf_
Переменная UserTasksMax в файле _/etc/systemd/logind.conf_ позволяет установить ограничение по максимальному 
количеству процессов на уровне пользователей

### Домашнее задание к занятию "3.5. Файловые системы"

1. Узнайте о sparse (разряженных) файлах.
Ответ: Разреженные файлы - это файлы, для которых выделяется пространство на диске только для участков с 
ненулевыми данными. Список всех "дыр" хранится в метаданных ФС и используется при операциях с файлами. В результате 
получается, что разреженный файл занимает меньше места на диске (более эффективное использование дискового пространства)
2. Могут ли файлы, являющиеся жесткой ссылкой на один объект, иметь разные права доступа и владельца? Почему?
Ответ: Не могут, так жесткие ссылки имеют один и тот же inode (объект, который содержит метаданные файла).
3. Сделайте vagrant destroy на имеющийся инстанс Ubuntu. Замените содержимое Vagrantfile следующим. Данная конфигурация
создаст новую виртуальную машину с двумя дополнительными неразмеченными дисками по 2.5 Гб.
Ответ: [скриншот_1](https://drive.google.com/file/d/113vuOmeSze1oLQu3gTFAOZ_BRlHsGwzc/view?usp=sharing)
4. Используя fdisk, разбейте первый диск на 2 раздела: 2 Гб, оставшееся пространство.
Ответ: [скриншот_2](https://drive.google.com/file/d/166XDTxVA7MK0N23k3IHHtLnINbaXRwFI/view?usp=sharing)
5. Используя sfdisk, перенесите данную таблицу разделов на второй диск.
Ответ: [скриншот_3](https://drive.google.com/file/d/1NRm-FFxwJYGi0tIeTKkqU2Bs09_m5FlH/view?usp=sharing)
6. Соберите mdadm RAID1 на паре разделов 2 Гб.
Ответ: [скриншот_4](https://drive.google.com/file/d/1TScV0kHjim815UgL7BmSECM1Kl8d5L4s/view?usp=sharing)
7. Соберите mdadm RAID0 на второй паре маленьких разделов.
Ответ: [скриншот_5 ](https://drive.google.com/file/d/1_v8mUh9aoAu6spUERnfi9kaf2N1mqZAu/view?usp=sharing)
8. Создайте 2 независимых PV на получившихся md-устройствах.
Ответ: [скриншот_6](https://drive.google.com/file/d/18NqJZmgnZtuDlxnuucsZp4GewCWjtKsK/view?usp=sharing)
9. Создайте общую volume-group на этих двух PV.
Ответ: [скриншот_7](https://drive.google.com/file/d/1o7rhjmKvNJAh79rj2Ak5ia7OiWpeFJAz/view?usp=sharing)
10. Создайте LV размером 100 Мб, указав его расположение на PV с RAID0.
Ответ: [скриншот_8](https://drive.google.com/file/d/1cmk_E-9xlnfyDC6gQzrELojVLI2WjwY9/view?usp=sharing)
11. Создайте mkfs.ext4 ФС на получившемся LV.
Ответ: [скриншот_9](https://drive.google.com/file/d/1FE22SR4J_4E2Th0n1oey5KHgTirLLQwd/view?usp=sharing) 
12. Смонтируйте этот раздел в любую директорию, например, /tmp/new.
Ответ: [скриншот_10 ](https://drive.google.com/file/d/150fcJWJbSbjAaR_SfNhhdWZWddvUsS5B/view?usp=sharing)
13. Поместите туда тестовый файл, например wget https://mirror.yandex.ru/ubuntu/ls-lR.gz -O /tmp/new/test.gz.
Ответ: [скриншот_11](https://drive.google.com/file/d/1KZI5466d8XsE3JpZyvBlLoY7qdOt8Vo1/view?usp=sharing)
14. Прикрепите вывод lsblk.
Ответ: [скриншот_12](https://drive.google.com/file/d/1z0VxucgHkh5qMLStf1bL4Hg7fo105u2Y/view?usp=sharing)
15. Протестируйте целостность файла:
Ответ: [скриншот_13](https://drive.google.com/file/d/1KbOVGUT4S1xco590JB0s66uW4p1fPGv2/view?usp=sharing)
16. Используя pvmove, переместите содержимое PV с RAID0 на RAID1.
Ответ: 

vagrant@vagrant:~$ sudo pvmove /dev/md1 /dev/md0  
  /dev/md1: Moved: 16.00%  
  /dev/md1: Moved: 100.00%  
vagrant@vagrant:~$ lsblk  
NAME                 MAJ:MIN RM  SIZE RO TYPE  MOUNTPOINT  
sda                    8:0    0   64G  0 disk  
├─sda1                 8:1    0  512M  0 part  /boot/efi   
├─sda2                 8:2    0    1K  0 part   
└─sda5                 8:5    0 63.5G  0 part   
  ├─vgvagrant-root   253:0    0 62.6G  0 lvm   /   
  └─vgvagrant-swap_1 253:1    0  980M  0 lvm   [SWAP]    
sdb                    8:16   0  2.5G  0 disk    
├─sdb1                 8:17   0    2G  0 part    
│ └─md0                9:0    0    2G  0 raid1    
│   └─VG1-LV1        253:2    0  100M  0 lvm   /tmp/new    
└─sdb2                 8:18   0  511M  0 part    
  └─md1                9:1    0 1018M  0 raid0    
sdc                    8:32   0  2.5G  0 disk    
├─sdc1                 8:33   0    2G  0 part    
│ └─md0                9:0    0    2G  0 raid1     
│   └─VG1-LV1        253:2    0  100M  0 lvm   /tmp/new    
└─sdc2                 8:34   0  511M  0 part    
  └─md1                9:1    0 1018M  0 raid0`    
17. Сделайте --fail на устройство в вашем RAID1 md.   
Ответ: [скриншот_17](https://drive.google.com/file/d/15hHPItrTJlSV2D2giZ4zbiXYDB7Jz9ce/view?usp=sharing)
18. Подтвердите выводом dmesg, что RAID1 работает в деградированном состоянии.
Ответ: [скриншот_18](https://drive.google.com/file/d/17jJ76rAGxFxa0XSgI7nfgCIoBEgpeWvD/view?usp=sharing)
19. Протестируйте целостность файла, несмотря на "сбойный" диск он должен продолжать быть доступен
Ответ [скриншот_19](https://drive.google.com/file/d/1_OVQ9yhG3mB9cAVGor9TIKl9hbmRH3gT/view?usp=sharing)
