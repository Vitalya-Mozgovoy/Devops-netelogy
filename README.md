


Домашнее задание к занятию "3.1. Работа в терминале, лекция 1"

1.Ознакомьтесь с графическим интерфейсом VirtualBox, посмотрите как выглядит виртуальная машина, которую создал для вас
Vagrant, какие аппаратные ресурсы ей выделены. Какие ресурсы выделены по-умолчанию?  
Ответ
По умолчанию выдано 2 CPU и 1024 MB RAM  
[скриншот](https://drive.google.com/file/d/1Tc3lQRyYFO_xWCsJiCLKhCCWcXSF5qnn/view?usp=sharing)  

2.Ознакомьтесь с возможностями конфигурации VirtualBox через Vagrantfile: документация. Как добавить оперативной памяти
или ресурсов процессора виртуальной машине?  
Ответ: Необходимо изменить конфиг файл vagrantfile и перезапустить ВМ (vagrant reload).  
Например 

 Vagrant.configure("2") do |config|  

 	config.vm.box = "bento/ubuntu-20.04"
	config.vm.provider "virtualbox" do |v|
		v.memory = 4128
		v.cpus = 4
	end
 end   
3. Какой переменной можно задать длину журнала history, и на какой строчке manual это описывается?  
 Ответ: Описывается начиная с 792 строчки манула  

4. Что делает директива ignoreboth в bash?  
Ответ: Директива ignoreboth делает тоже самое что и директива ignorespace:ignoredups.
Если в файл ~/.bashrc добавить строку HISTCONTROL=ignoreboth или
HISTCONTROL=ignoreboth:erasedups в истории не будут сохраняться строки начинающиеся с символа пробел и дублирующиеся
(совпадающие с последней выполненной) команды.  
5. В каких сценариях использования применимы скобки {} и на какой строчке man bash это описано?  
Ответ: Строка 241, {} применяется для создания составных комманд, команды находящиеся в {} будут выполнены в
контексте текущего процесса (терминала), и результаты их вызова будут сохранены в текущем контексте (можно задать
функции имя и в последствии в данном терминале неоднократно вызывать её).
Команды выполненные в () будут исполнятся в дочернем процессе и после отработки удаляться из памяти.  
6. Основываясь на предыдущем вопросе, как создать однократным вызовом touch 100000 файлов?
А получилось ли создать 300000? Если нет, то почему?  
Ответ: touch {1..300000} не удалось создать без изменения переменной ARG_MAX (увеличить ограничение 
на объём передаваемых аргументов комманде) в большинстве случаев не получится.  
[Скриншот](https://drive.google.com/file/d/1NMtObGmaZMqxc-ZnQyDUpUp6tWdXFJWi/view?usp=sharing) 
7. В man bash поищите по /\[\[. Что делает конструкция [[ -d /tmp ]].  
Ответ: Конструкция [[ -d /tmp ]] вернёт 0 при наличии каталога /tmp.  
8. Основываясь на знаниях о просмотре текущих (например, PATH) и установке новых переменных; командах,
которые мы рассматривали, добейтесь в выводе type -a bash в виртуальной машине наличия первым пунктом в списке  
Ответ: 
# Создаем каталог
mkdir /tmp/new_path_directory
# Копируем в него файл bash
cp /bin/bash /tmp/new_path_directory/
# Добавляем каталог в переменную $PATH (в начало) 
PATH=/tmp/new_path_directory/bash:$PATH
# Выводим переменную, чтобы убедиться в корректности
echo $PATH
# Выполняем type -a
type -a bash  
[Скриншот ](https://drive.google.com/file/d/1ig26zF7p1cSCV1-N3K9PhLDB4FYe5nQB/view?usp=sharing) 
9. Чем отличается планирование команд с помощью batch и at?  
At используется для планирования разовой задачи, которая должна выполниться в определенное время
Batch используется для выполнения разовой задачи, когда позволит средняя нагрузка 
(в man указано, когда средняя нагрузка упадет ниже 1.5)  


# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2


Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете   
что она могла бы быть другого типа.

Ответ:  cd - это shell builtin команда, то есть команда, которая вызывается напрямую в shell, а не как   
внешняя исполняемая. Если бы она была внешней, то запускалась бы в отдельном процессе но мы этого не наблюдаем

Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l?  

Ответ: grep <some_string> <some_file> -c


Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

Ответ: [Скриншот ](https://drive.google.com/file/d/1RIWoAj_d2Es2GcXuBL92W9FefNR4PLms/view?usp=sharing)  

Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

Ответ: Для этого откроем второй терминал для наглядности и с имитируем ошибку [пример](https://drive.google.com/file/d/1lJYSAsYHm1Wr0A8oUyt434tIECdvlx3o/view?usp=sharing)
ls -l \root 2>/dev/pts/1

Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.  
Ответ: Да получиться например вот так:  
cat <test1.txt >test.txt  
vagrant@vagrant:~$ echo Привет >test1.txt  
vagrant@vagrant:~$ cat <test1.txt >test.txt  
vagrant@vagrant:~$ cat test.txt  
Привет  

Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY?  
Сможете ли вы наблюдать выводимые данные?

Ответ: Да получиться  

Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните
echo netology > /proc/$$/fd/5? Почему так происходит?

Ответ: bash 5>&1 -перенаправит вывод с созданного дескриптора 5 в stdout (дескриптор 1).
echo netology > /proc/$$/fd/5 -выведет в дескриптор 5 "netology",
т.к. дескриптор 5 перенаправлен в stdout "netology" мы увидим в терминале.  


Получится ли в качестве входного потока для pipe использовать только stderr команды,
не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout 
команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный
новый дескриптор, который вы научились создавать в предыдущем вопросе.

Решение: 

vagrant@vagrant:~$ ls -l /root 9>&2 2>&1 1>&9 |grep denied -c   
1

9>&2 - новый дескриптор перенаправили в stderr  
2>&1 - stderr перенаправили в stdout   
1>&9 - stdout - перенаправили в в новый дескриптор  

Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

Ответ: Выводится список переменных окружения для процесса, под которым выполняется текущая оболочка  
Аналогичный вывод можно получить с помощью команды printenv

Используя man, опишите что доступно по адресам /proc//cmdline, /proc//exe

Ответ: /proc/[pid]/cmdline - файл только на чтение, который содержит строку запуска процессов, 
кроме зомби-процессов 
/proc/[pid]/exe - сожержит полное имя выполняемого файла для процесса 


Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с
помощью /proc/cpuinfo

Ответ [скриншот](https://drive.google.com/file/d/1317WVYOJPo3wOyYT_Dz4t3eLgcmCpB7B/view?usp=sharing)

При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить
командой tty, которая упоминалась в лекции 3.2
Решение:
По умолчанию при запуске команды через SSH не выделяется TTY. Если же не указывать команды,
то TTY будет выдаваться, так как предполагается, что будет запущен сеанс оболочки. Полагаю, что изменить поведение 
можно через ssh localhost с последующей авторизацией и выполнением 'tty'. Либо через ssh -t localhost 'tty'


Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это,
воспользовавшись reptyr. Например, так можно перенести в screen процесс,
который вы запустили по ошибке в обычной SSH-сессии.

Решешие: Получилось после правки /proc/sys/kernel/yama/ptrace_scope

Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

Ответ tee - получает значения из stdin и записывает их в stdout и файл.Будет работать т.к.
в данном случае запись в файл будет осуществляться командой tee запущенной от рута
(и соответственно имеющей необходимые права).


### Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

1.Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой,
это shell builtin, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете
запустить strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, которые
делает сам bash при старте. Вам нужно найти тот единственный, который относится именно к cd.

Ответ: вводим  strace /bin/bash -c cd /tmp и находим _chdir()_

2. Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:

vagrant@netology1:~$ file /dev/tty
/dev/tty: character special (5/0)
vagrant@netology1:~$ file /dev/sda
/dev/sda: block special (8/0)
vagrant@netology1:~$ file /bin/bash
/bin/bash: ELF 64-bit LSB shared object, x86-64

Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.
Ответ Аналогично командой strace смотрим системные вызовы openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3
Файл базы типов - /usr/share/misc/magic.mgc

3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности  
сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает  
писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении  
потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе). 
Ответ: Попробовал с текстовым редактором vim

vagrant@vagrant:~$ lsof -p 1126
...
vi      1126 vagrant    4u   REG  253,0    12288  526898 /home/vagrant/.tst_bash.swp (deleted)


vagrant@vagrant:~$ echo '' >/proc/1126/fd/4



где 1126 - PID процесса vi
4 - дескриптор файла , который предварительно удалил. 

4.Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
Ответ  Нет не занимают

5. В iovisor BCC есть утилита opensnoop:

root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc

На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты?  
Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по установке.

Ответ. 

6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается  
альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС. 

Ответ: системный вызов uname()
Цитата 
     Part of the utsname information is also accessible  via  /proc/sys/ker‐
       nel/{ostype, hostname, osrelease, version, domainname}.  
7.Чем отличается последовательность команд через ; и через && в bash? Например:

root@netology1:~# test -d /tmp/some_dir; echo Hi
Hi
root@netology1:~# test -d /tmp/some_dir && echo Hi
root@netology1:~#

Есть ли смысл использовать в bash &&, если применить set -e?
Ответ:

&& -  условный оператор, 
а ;  - разделитель последовательных команд

test -d /tmp/some_dir && echo Hi - в данном случае echo  отработает только при успешном заверщении команды test

set -e - прерывает сессию при любом ненулевом значении исполняемых команд в конвеере кроме последней.
в случае &&  вместе с set -e- вероятно не имеет смысла, так как при ошибке , выполнение команд прекратиться. 

8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях? 

Ответ:
-e прерывает выполнение исполнения при ошибке любой команды кроме последней в последовательности 
-x вывод трейса простых команд 
-u неустановленные/не заданные параметры и переменные считаются как ошибки, с выводом в stderr текста ошибки и   
выполнит завершение неинтерактивного вызова
-o pipefail возвращает код возврата набора/последовательности команд, ненулевой при последней команды или 0   
для успешного выполнения команд.

По сути, для сценария , повышает деталезацию вывода ошибок(логирования), 
и завершит сценарий при наличии ошибок, на любом этапе выполнения сценария, кроме последней завершающей команды

9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).
Ответ:

S*(S,S+,Ss,Ssl,Ss+) - Процессы ожидающие завершения (спящие с прерыванием "сна")
I*(I,I<) - фоновые(бездействующие) процессы ядра

доп символы это доп характеристики, например приоритет.

###### Домашнее задание к занятию "3.4. Операционные системы, лекция 2"


1.На лекции мы познакомились с node_exporter. В демонстрации его исполняемый файл запускался в background.
Этого достаточно для демо, но не для настоящей production-системы, где процессы должны находиться под внешним 
управлением. Используя знания из лекции по systemd, создайте самостоятельно простой unit-файл для node_exporter:
поместите его в автозагрузку,
предусмотрите возможность добавления опций к запускаемому процессу через внешний
файл (посмотрите, например, на systemctl cat cron),
удостоверьтесь, что с помощью systemctl процесс корректно стартует, 
завершается, а после перезагрузки автоматически поднимается.

Решение

Node Exporter установлен и запускается

создан unit-файл для Node Exporter предусматривающий добавление опций $OPTIONS к запускаемому процессу
через внешний файл /etc/sysconfig/node_exporter

командой sudo systemctl enable node_exporter Node Exporter добавлен в автозагрузку
node exporter корректно стартует, завершается и после перезагрузки автоматически поднимается

у Node Exporter имеется переменная окружения для добавления опций к запускаемому процессу

node exporter после перезагрузки виртуальной машины автоматически поднимается


Ознакомьтесь с опциями node_exporter и выводом /metrics по-умолчанию. Приведите несколько опций, 
которые вы бы выбрали для базового мониторинга хоста по CPU, памяти, диску и сети.


--collector.disable-defaults
--collector.cpu
--collector.cpufreq
--collector.meminfo
--collector.diskstats
--collector.netstat


Установите в свою виртуальную машину Netdata. Воспользуйтесь готовыми пакетами 
для установки (sudo apt install -y netdata). После успешной установки:

в конфигурационном файле /etc/netdata/netdata.conf в секции [web] замените значение с localhost на bind to = 0.0.0.0,
добавьте в Vagrantfile проброс порта Netdata на свой локальный компьютер и сделайте vagrant reload:


config.vm.network "forwarded_port", guest: 19999, host: 19999
После успешной перезагрузки в браузере на своем ПК (не в виртуальной машине) вы должны суметь зайти на localhost:19999.
Ознакомьтесь с метриками, которые по умолчанию собираются Netdata и с комментариями, которые даны к этим метрикам.
Решение

Netdata установлена на виртуальной машине и открывается с хоста
[скрин](https://drive.google.com/file/d/1l3TE5yjwLbT69Ilmb2MuYtF0xjDI0IZ-/view?usp=sharing)

Можно ли по выводу dmesg понять, осознает ли ОС, что загружена не на настоящем оборудовании, а на системе виртуализации?
Ответ
Да, данная информация содержится в dmesg



Как настроен sysctl fs.nr_open на системе по-умолчанию? Узнайте, что означает этот параметр. Какой другой существующий
лимит не позволит достичь такого числа (ulimit --help)?

Ответ
nr_open - означает максимальное число дескрипторов, которые может использовать процесс. Но этого значения не дает достичь другой лимит

vagrant@vagrant:~$ ulimit -n
1024

Запустите любой долгоживущий процесс (не ls, который отработает мгновенно, а, например, sleep 1h) в отдельном 
неймспейсе процессов; покажите, что ваш процесс работает под PID 1 через nsenter. Для простоты работайте в данном
задании под root (sudo -i). Под обычным пользователем требуются дополнительные опции (--map-root-user) и т.д.
Решение 
vagrant@vagrant:~$ sudo unshare -f --pid --mount-proc sleep 1h
vagrant@vagrant:~$ ps -aux | grep sleep
root        2517  0.0  0.4  11864  4624 pts/1    S+   14:02   0:00 sudo unshare -f --pid --mount-proc sleep 1h
root        2518  0.0  0.0   8080   592 pts/1    S+   14:02   0:00 unshare -f --pid --mount-proc sleep 1h
root        2519  0.0  0.0   8076   580 pts/1    S+   14:02   0:00 sleep 1h

vagrant@vagrant:~$ sudo nsenter --target 2519 --pid --mount
root@vagrant:/# ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.0   8076   580 pts/1    S+   14:02   0:00 sleep 1h
root           2  0.0  0.4   9836  4144 pts/2    S    14:05   0:00 -bash
root          11  0.0  0.3  11492  3292 pts/2    R+   14:05   0:00 ps aux

Найдите информацию о том, что такое :(){ :|:& };:. Запустите эту команду в своей виртуальной машине Vagrant
с Ubuntu 20.04 (это важно, поведение в других ОС не проверялось). Некоторое время все будет "плохо",
после чего (минуты) – ОС должна стабилизироваться. Вызов dmesg расскажет, какой механизм помог автоматической 
стабилизации. Как настроен этот механизм по-умолчанию, и как изменить число процессов, которое можно создать в сессии?

Ответ
Судя по информации, что я нашел в интернете - это fork bomb Её можно переписать в виде

:(){
 :|:&
};:

или

bomb() { 
 bomb | bomb &
}; bomb

Данная функция рекурсивно вызывает себя и передается через пайп другому вызову этой же функции (в фоне).
По сути запускаются 2 фоновых процесса, каждый из которых вызывает еще два фоновых процесса 
и тд, пока не закончатся ресурсы. 
[ 5667.545996] cgroup: fork rejected by pids controller in /user.slice/user-1000.slice/session-6.scope

vagrant@vagrant:~$ ulimit -u
3571

Максимальное количество процессов для пользователя можно изменить командой ulimit -u <число> или 
в файле cat etc/security/limits.conf
Изменить максимальное количество PID можно посредством команд sysctl -w kernel.pid_max=<число>,echo <число> >
/proc/sys/kernel/pid_max или задать переменную kernel.pid_max в файле  /etc/sysctl.conf
Ограничение на максимальное число процессов на уровне системы установлено в переменной DefaultTasksMax:
systemctl show --property DefaultTasksMax изменить данную переменную можно в файле /etc/systemd/system.conf
Переменная UserTasksMax в файле /etc/systemd/logind.conf позволяет установить ограничение по максимальному 
количеству процессов на уровне пользователей